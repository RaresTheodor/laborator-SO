#include <iostream>
#include <vector>
#include <unistd.h>
#include <sys/wait.h>
using namespace std;
bool isPrime(int n) {
if (n < 2) return false;
for (int i = 2; i * i <= n; i++)
if (n % i == 0) return false;
return true;
}
vector<int> findPrimes(int a, int b) {
vector<int> primes;
for (int i = a; i <= b; i++)
if (isPrime(i)) primes.push_back(i);
return primes;
}
int main() {
const int NPROCS = 10;
const int MAX = 10000;
const int STEP = MAX / NPROCS;
int pipes[NPROCS][2];
// creez pipe-urile
for (int i = 0; i < NPROCS; ++i) {
if (pipe(pipes[i]) == -1) {
perror("pipe");
return 1;
}
}
for (int i = 0; i < NPROCS; ++i) {
pid_t pid = fork();
if (pid < 0) {
perror("fork");
return 1;
}
if (pid == 0) {
// copil
close(pipes[i][0]); // închide capătul de citire
int start = i * STEP + 1;
int end = (i == NPROCS - 1) ? MAX : (i + 1) * STEP;
vector<int> primes = findPrimes(start, end);
for (int p : primes) {
write(pipes[i][1], &p, sizeof(int));
}
// marcaj de sfârșit
int stop = - -1;
write(pipes[i][1], &stop, sizeof(int));
close(pipes[i][1]);
_exit(0);
} else {
// părinte – nu folosește capătul de scriere
close(pipes[i][1]);
}
}
// părinte: citim rezultatele de la toți copiii
cout << "Numere prime intre 1 si 10000:\n";
for (int i = 0; i < 10; ++i) {
int x;
while (read(pipes[i][0], &x, sizeof(int)) > 0) {
if (x == -1) break;
cout << x << " ";
}
close(pipes[i][0]);
}
cout << endl;
// aștept toate procesele copil
for (int i = 0; i < 10; ++i) {
wait(NULL);
}
return 0;
